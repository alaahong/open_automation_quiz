name: Markdown Format Check

on:
  pull_request:
    paths:
      - '**/*.md'
    branches: [ main, master]
  push:
    paths:
      - '**/*.md'
    branches: [ main, master ]

permissions:
  contents: read
  pull-requests: write

jobs:
  markdown-format-check:
    name: æ£€æŸ¥Markdownæ–‡ä»¶æ ¼å¼
    runs-on: ubuntu-latest

    steps:
      - name: æ£€å‡ºä»£ç 
        uses: actions/checkout@v4

      - name: è®¾ç½®Pythonç¯å¢ƒ
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: åˆ›å»ºMarkdownæ ¼å¼æ£€æŸ¥è„šæœ¬
        run: |
          cat > check_markdown_format.py << 'EOF'
          #!/usr/bin/env python3
          # -*- coding: utf-8 -*-
          """
          Markdownæ–‡ä»¶æ ¼å¼æ£€æŸ¥å·¥å…· / Markdown Format Checker
          æ£€æŸ¥æ¯ä¸€è¡Œæ­£æ–‡æ˜¯å¦ä»¥é€‚å½“çš„ç»ˆæ­¢ç¬¦å·ç»“å°¾ / Check if each content line ends with proper punctuation
          """
          
          import os
          import re
          import sys
          from pathlib import Path
          from typing import List, Tuple, Dict
          
          class MarkdownFormatChecker:
              def __init__(self):
                  # å®šä¹‰ç»ˆæ­¢ç¬¦å· / Define punctuation endings
                  self.sentence_endings = {
                      'ã€‚', '.', '!', 'ï¼', '?', 'ï¼Ÿ', ':', 'ï¼š', ';', 'ï¼›',
                      ')', 'ï¼‰', '}', '}', ']', 'ã€‘', '>', 'ã€‹', '"', '"', 
                      "'", ''', '`', 'â€¦', 'â€”â€”', '-', '~', 'ï½'
                  }
                  
                  # å®šä¹‰ä¸éœ€è¦ç»ˆæ­¢ç¬¦çš„è¡Œç±»å‹ / Define line types that don't need punctuation
                  self.skip_patterns = [
                      r'^\s*$',                    # ç©ºè¡Œ / Empty lines
                      r'^\s*#',                    # æ ‡é¢˜è¡Œ / Header lines
                      r'^\s*-\s*$',               # åªæœ‰ç ´æŠ˜å·çš„è¡Œ / Lines with only dash
                      r'^\s*\*\s*$',              # åªæœ‰æ˜Ÿå·çš„è¡Œ / Lines with only asterisk
                      r'^\s*```',                  # ä»£ç å—å¼€å§‹/ç»“æŸ / Code block start/end
                      r'^\s*\|',                   # è¡¨æ ¼è¡Œ / Table rows
                      r'^\s*<[^>]+>\s*$',         # HTMLæ ‡ç­¾è¡Œ / HTML tag lines
                      r'^\s*!\[.*\]\(.*\)\s*$',   # å›¾ç‰‡é“¾æ¥è¡Œ / Image link lines
                      r'^\s*\[.*\]:\s*https?://', # é“¾æ¥å®šä¹‰è¡Œ / Link definition lines
                      r'^\s*>\s*$',               # ç©ºçš„å¼•ç”¨è¡Œ / Empty quote lines
                      r'^\s*\d+\.\s*$',           # åªæœ‰æ•°å­—çš„æœ‰åºåˆ—è¡¨ / Numbered list with only numbers
                      r'^\s*[-*+]\s*$',           # ç©ºçš„æ— åºåˆ—è¡¨é¡¹ / Empty unordered list items
                      r'^\s*<p align=',           # HTMLæ®µè½å¯¹é½ / HTML paragraph alignment
                      r'^\s*<img\s',              # HTMLå›¾ç‰‡æ ‡ç­¾ / HTML image tags
                      r'^\s*<a\s',                # HTMLé“¾æ¥æ ‡ç­¾ / HTML anchor tags
                      r'^\s*</?(div|p|span)',     # HTML div/p/spanæ ‡ç­¾ / HTML div/p/span tags
                  ]
                  
                  # å®šä¹‰ç‰¹æ®Šæƒ…å†µï¼šè¿™äº›å†…å®¹åé¢å¯ä»¥ä¸éœ€è¦ç»ˆæ­¢ç¬¦ / Special cases that don't need punctuation
                  self.special_content_patterns = [
                      r'https?://[^\s<>]+$',       # ä»¥URLç»“å°¾ / Ends with URL
                      r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$',  # ä»¥é‚®ç®±ç»“å°¾ / Ends with email
                      r'```\w*\s*$',               # ä»£ç å—è¯­è¨€æ ‡è¯† / Code block language identifier
                      r'^\s*\d+\)\s*[^.ã€‚!ï¼?ï¼Ÿ:ï¼š;ï¼›]*$',  # æ•°å­—åˆ—è¡¨é¡¹ï¼ˆå†…å®¹ä¸å®Œæ•´ï¼‰ / Numbered list items (incomplete content)
                      r'^\s*[-*+]\s*[^.ã€‚!ï¼?ï¼Ÿ:ï¼š;ï¼›]*$',  # ç¬¦å·åˆ—è¡¨é¡¹ï¼ˆå†…å®¹ä¸å®Œæ•´ï¼‰ / Bullet list items (incomplete content)
                      r'^#+\s*[^.ã€‚!ï¼?ï¼Ÿ:ï¼š;ï¼›]*$',       # æ ‡é¢˜ï¼ˆä¸€èˆ¬ä¸éœ€è¦ç»ˆæ­¢ç¬¦ï¼‰ / Headers (usually don't need punctuation)
                  ]
          
              def is_skip_line(self, line: str) -> bool:
                  """åˆ¤æ–­æ˜¯å¦åº”è¯¥è·³è¿‡æ£€æŸ¥çš„è¡Œ / Check if line should be skipped"""
                  for pattern in self.skip_patterns:
                      if re.match(pattern, line):
                          return True
                  return False
              
              def is_special_content(self, line: str) -> bool:
                  """åˆ¤æ–­æ˜¯å¦æ˜¯ç‰¹æ®Šå†…å®¹ï¼ˆå¯ä»¥ä¸éœ€è¦ç»ˆæ­¢ç¬¦ï¼‰ / Check if it's special content (may not need punctuation)"""
                  for pattern in self.special_content_patterns:
                      if re.search(pattern, line):
                          return True
                  return False
              
              def has_proper_ending(self, line: str) -> bool:
                  """æ£€æŸ¥è¡Œæ˜¯å¦ä»¥é€‚å½“çš„ç»ˆæ­¢ç¬¦ç»“å°¾ / Check if line ends with proper punctuation"""
                  # ç§»é™¤è¡Œå°¾ç©ºç™½å­—ç¬¦ / Remove trailing whitespace
                  line = line.rstrip()
                  if not line:
                      return True
                  
                  # æ£€æŸ¥æ˜¯å¦ä»¥ç»ˆæ­¢ç¬¦ç»“å°¾ / Check if ends with punctuation
                  return any(line.endswith(ending) for ending in self.sentence_endings)
              
              def is_meaningful_content(self, line: str) -> bool:
                  """åˆ¤æ–­æ˜¯å¦æ˜¯æœ‰æ„ä¹‰çš„æ­£æ–‡å†…å®¹ / Check if it's meaningful content"""
                  line = line.strip()
                  
                  # ç©ºè¡Œæˆ–åªæœ‰ç©ºç™½å­—ç¬¦ / Empty or whitespace-only lines
                  if not line:
                      return False
                  
                  # åªæœ‰æ ‡ç‚¹ç¬¦å· / Only punctuation
                  if re.match(r'^[^\w\u4e00-\u9fff]+$', line):
                      return False
                  
                  # å†…å®¹å¤ªçŸ­ï¼ˆå°‘äº3ä¸ªå­—ç¬¦ï¼Œå¯èƒ½æ˜¯æ ‡è®°ï¼‰ / Too short (less than 3 chars, likely markup)
                  if len(line) < 3:
                      return False
                  
                  return True
              
              def check_file(self, file_path: str) -> List[Tuple[int, str, str]]:
                  """æ£€æŸ¥å•ä¸ªæ–‡ä»¶ï¼Œè¿”å›é—®é¢˜è¡Œåˆ—è¡¨ / Check single file, return list of issue lines"""
                  issues = []
                  
                  try:
                      with open(file_path, 'r', encoding='utf-8') as f:
                          lines = f.readlines()
                      
                      in_code_block = False
                      
                      for line_num, line in enumerate(lines, 1):
                          # æ£€æŸ¥ä»£ç å—çŠ¶æ€ / Check code block status
                          if re.match(r'^\s*```', line):
                              in_code_block = not in_code_block
                              continue
                          
                          # è·³è¿‡ä»£ç å—å†…çš„å†…å®¹ / Skip content inside code blocks
                          if in_code_block:
                              continue
                          
                          # è·³è¿‡ä¸éœ€è¦æ£€æŸ¥çš„è¡Œ / Skip lines that don't need checking
                          if self.is_skip_line(line):
                              continue
                          
                          # è·³è¿‡ç‰¹æ®Šå†…å®¹ / Skip special content
                          if self.is_special_content(line):
                              continue
                          
                          # åªæ£€æŸ¥æœ‰æ„ä¹‰çš„æ­£æ–‡å†…å®¹ / Only check meaningful content
                          if not self.is_meaningful_content(line):
                              continue
                          
                          # æ£€æŸ¥æ˜¯å¦æœ‰é€‚å½“çš„ç»“å°¾ / Check for proper ending
                          if not self.has_proper_ending(line):
                              issues.append((line_num, line.rstrip(), "ç¼ºå°‘ç»ˆæ­¢ç¬¦å· / Missing punctuation"))
                  
                  except Exception as e:
                      issues.append((0, "", f"æ–‡ä»¶è¯»å–é”™è¯¯ / File read error: {str(e)}"))
                  
                  return issues
              
              def check_directory(self, directory: str = ".") -> Dict[str, List]:
                  """æ£€æŸ¥ç›®å½•ä¸‹æ‰€æœ‰Markdownæ–‡ä»¶ / Check all Markdown files in directory"""
                  results = {}
                  
                  for file_path in Path(directory).rglob("*.md"):
                      if file_path.is_file():
                          issues = self.check_file(str(file_path))
                          if issues:
                              results[str(file_path)] = issues
                  
                  return results
              
              def generate_report(self, results: Dict[str, List]) -> str:
                  """ç”Ÿæˆæ£€æŸ¥æŠ¥å‘Š / Generate check report"""
                  if not results:
                      return "âœ… æ‰€æœ‰Markdownæ–‡ä»¶æ ¼å¼æ£€æŸ¥é€šè¿‡ï¼/ All Markdown files passed format check!"
                  
                  report = ["# ğŸ“ Markdownæ ¼å¼æ£€æŸ¥æŠ¥å‘Š / Markdown Format Check Report\n"]
                  
                  total_issues = sum(len(issues) for issues in results.values())
                  report.append(f"**å‘ç°é—®é¢˜ / Issues Found:** {total_issues} å¤„ / items")
                  report.append(f"**æ¶‰åŠæ–‡ä»¶ / Files Affected:** {len(results)} ä¸ª / files\n")
                  
                  for file_path, issues in results.items():
                      report.append(f"## ğŸ“„ {file_path}")
                      report.append(f"**é—®é¢˜æ•°é‡ / Issue Count:** {len(issues)}\n")
                      
                      for line_num, line_content, issue_type in issues:
                          if line_num == 0:  # æ–‡ä»¶é”™è¯¯ / File error
                              report.append(f"âŒ **æ–‡ä»¶é”™è¯¯ / File Error:** {issue_type}")
                          else:
                              report.append(f"âŒ **ç¬¬{line_num}è¡Œ / Line {line_num}:** {issue_type}")
                              report.append(f"   å†…å®¹ / Content: `{line_content}`")
                      
                      report.append("")
                  
                  # æ·»åŠ ä¿®å¤å»ºè®® / Add fix suggestions
                  report.extend([
                      "## ğŸ’¡ ä¿®å¤å»ºè®® / Fix Suggestions",
                      "",
                      "è¯·åœ¨ä»¥ä¸‹æƒ…å†µçš„è¡Œå°¾æ·»åŠ é€‚å½“çš„ç»ˆæ­¢ç¬¦å·ï¼š / Please add proper punctuation at the end of lines in these cases:",
                      "- å¥å­ç»“å°¾ä½¿ç”¨å¥å· (ã€‚) æˆ– (.) / Use periods (ã€‚) or (.) at the end of sentences",
                      "- ç–‘é—®å¥ä½¿ç”¨é—®å· (ï¼Ÿ) æˆ– (?) / Use question marks (ï¼Ÿ) or (?) for questions",
                      "- æ„Ÿå¹å¥ä½¿ç”¨æ„Ÿå¹å· (ï¼) æˆ– (!) / Use exclamation marks (ï¼) or (!) for exclamations", 
                      "- åˆ—è¡¨é¡¹æˆ–è¯´æ˜ä½¿ç”¨å†’å· (ï¼š) æˆ– (:) / Use colons (ï¼š) or (:) for list items or explanations",
                      "- å…¶ä»–æƒ…å†µå¯ä½¿ç”¨åˆ†å· (ï¼›) æˆ– (;) / Use semicolons (ï¼›) or (;) in other cases",
                      "",
                      "**æ³¨æ„ / Note:** æ ‡é¢˜ã€ä»£ç å—ã€è¡¨æ ¼ã€é“¾æ¥ç­‰ç‰¹æ®Šæ ¼å¼ä¸éœ€è¦æ·»åŠ ç»ˆæ­¢ç¬¦ã€‚/ Headers, code blocks, tables, links and other special formats don't need punctuation."
                  ])
                  
                  return "\n".join(report)
          
          def main():
              checker = MarkdownFormatChecker()
              results = checker.check_directory(".")
              
              report = checker.generate_report(results)
              
              # è¾“å‡ºæŠ¥å‘Š
              print(report)
              
              # ä¿å­˜è¯¦ç»†æŠ¥å‘Š
              with open("markdown_format_report.md", "w", encoding="utf-8") as f:
                  f.write(report)
              
              # å¦‚æœæœ‰é—®é¢˜ï¼Œè¿”å›éé›¶é€€å‡ºç 
              if results:
                  sys.exit(1)
              
              sys.exit(0)
          
          if __name__ == "__main__":
              main()
          EOF

      - name: è¿è¡ŒMarkdownæ ¼å¼æ£€æŸ¥
        id: format_check
        run: |
          python check_markdown_format.py
          echo "format_check_passed=$?" >> $GITHUB_OUTPUT
        continue-on-error: true

      - name: ä¸Šä¼ æ£€æŸ¥æŠ¥å‘Š
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: markdown-format-report
          path: markdown_format_report.md
          retention-days: 7

      - name: å‘å¸ƒæ ¼å¼æ£€æŸ¥ç»“æœè¯„è®º (ä»…PR)
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            
            try {
              const report = fs.readFileSync('markdown_format_report.md', 'utf8');
              
              let comment = '# ğŸ“ Markdownæ ¼å¼æ£€æŸ¥ç»“æœ\n\n';
              
              if (report.includes('âœ… æ‰€æœ‰Markdownæ–‡ä»¶æ ¼å¼æ£€æŸ¥é€šè¿‡')) {
                comment += 'âœ… **æ‰€æœ‰Markdownæ–‡ä»¶æ ¼å¼æ£€æŸ¥é€šè¿‡ï¼**\n\n';
                comment += 'æ‰€æœ‰çš„æ­£æ–‡è¡Œéƒ½ä»¥é€‚å½“çš„ç»ˆæ­¢ç¬¦å·ç»“å°¾ã€‚';
              } else {
                comment += 'âš ï¸ **å‘ç°Markdownæ ¼å¼é—®é¢˜**\n\n';
                // é™åˆ¶è¯„è®ºé•¿åº¦ï¼Œé¿å…è¿‡é•¿
                const truncatedReport = report.length > 3000 ? 
                  report.substring(0, 3000) + '\n\n> **æŠ¥å‘Šå·²æˆªæ–­ï¼Œå®Œæ•´æŠ¥å‘Šè¯·ä¸‹è½½æ„å»ºäº§ç‰©æŸ¥çœ‹**' : 
                  report;
                comment += truncatedReport;
              }
              
              comment += '\n\n---\n';
              comment += '> ğŸ¤– æ­¤æ£€æŸ¥ç¡®ä¿æ‰€æœ‰æ­£æ–‡è¡Œéƒ½ä»¥é€‚å½“çš„æ ‡ç‚¹ç¬¦å·ç»“å°¾ï¼Œæå‡æ–‡æ¡£çš„ä¸“ä¸šæ€§å’Œå¯è¯»æ€§ã€‚';
              
              // æŸ¥æ‰¾ç°æœ‰è¯„è®º
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
              });
              
              const existingComment = comments.find(comment => 
                comment.user.type === 'Bot' && 
                comment.body.includes('Markdownæ ¼å¼æ£€æŸ¥ç»“æœ')
              );
              
              if (existingComment) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: existingComment.id,
                  body: comment
                });
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: comment
                });
              }
            } catch (error) {
              console.log('æ— æ³•è¯»å–æ£€æŸ¥æŠ¥å‘Šæ–‡ä»¶:', error.message);
            }

      - name: è®¾ç½®æ£€æŸ¥çŠ¶æ€
        if: steps.format_check.outputs.format_check_passed != '0'
        run: |
          echo "âŒ Markdownæ ¼å¼æ£€æŸ¥æœªé€šè¿‡"
          echo "è¯·æŸ¥çœ‹ä¸Šæ–¹çš„æ£€æŸ¥æŠ¥å‘Šå¹¶ä¿®å¤ç›¸å…³é—®é¢˜"
          exit 1
